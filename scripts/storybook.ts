#!/usr/bin/env node

/**
 * Storybook Module - Generate Storybook UI documentation from TypeScript interfaces
 * Usage: storybook.ts <generatedTypes.json> [--template templates/storybook.md] [--assets assets/ui]
 *
 * Creates interactive documentation for generated interfaces with:
 * - Type hierarchy visualization
 * - Property explorers with examples
 * - Interactive type testing
 */

import * as fs from 'fs';
import * as path from 'path';

interface ParsedField {
  name: string;
  type: string;
  required?: boolean;
  description?: string;
}

interface ParsedType {
  name: string;
  kind: 'interface' | 'type' | 'enum';
  fields?: ParsedField[];
  values?: string[];
  extends?: string[];
}

interface ParserOutput {
  types: ParsedType[];
  metadata: {
    source: string;
    timestamp: string;
    rootType: string;
  };
}

interface StorybookOptions {
  templatePath?: string;
  assetsPath?: string;
  outputPath?: string;
  title?: string;
}

class StorybookGenerator {
  private template: string;
  private assetsPath: string;
  private title: string;

  private uiStyles: string = `/* Storybook UI Styles */
.storybook-type-card {
  border: 1px solid #e1e5e9;
  border-radius: 8px;
  padding: 16px;
  margin: 12px 0;
  background: #f6f8fa;
  font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
}

.storybook-type-card h3 {
  margin-top: 0;
  color: #0366d6;
  font-size: 1.2em;
}

.storybook-type-card .tag {
  display: inline-block;
  padding: 2px 8px;
  border-radius: 12px;
  font-size: 0.75em;
  font-weight: 600;
  margin-right: 8px;
}

.storybook-type-card .tag.interface { background: #28a745; color: white; }
.storybook-type-card .tag.type { background: #6f42c1; color: white; }
.storybook-type-card .tag.enum { background: #fd7e14; color: white; }

.storybook-type-card .required { color: #d73a49; }
.storybook-type-card .optional { color: #28a745; }

.storybook-property-table {
  width: 100%;
  border-collapse: collapse;
  margin-top: 12px;
}

.storybook-property-table th,
.storybook-property-table td {
  text-align: left;
  padding: 8px 12px;
  border-bottom: 1px solid #e1e5e9;
}

.storybook-property-table th {
  background: #f1f3f5;
  font-weight: 600;
}

.storybook-example {
  background: #282c34;
  color: #abb2bf;
  padding: 16px;
  border-radius: 6px;
  overflow-x: auto;
  font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
  font-size: 0.9em;
  margin-top: 12px;
}

.storybook-type-hierarchy {
  margin-bottom: 24px;
}

.storybook-type-hierarchy ul {
  list-style: none;
  padding-left: 20px;
}

.storybook-type-hierarchy li::before {
  content: "├─ ";
  color: #666;
  margin-right: 4px;
}

.storybook-search {
  width: 100%;
  padding: 12px 16px;
  border: 1px solid #ddd;
  border-radius: 6px;
  font-size: 1em;
  margin-bottom: 24px;
  box-sizing: border-box;
}`;

  constructor(options: StorybookOptions = {}) {
    this.assetsPath = options.assetsPath || 'assets/ui';
    this.title = options.title || 'API Interface Documentation';
    this.template = options.templatePath && fs.existsSync(options.templatePath)
      ? fs.readFileSync(options.templatePath, 'utf8')
      : this.getDefaultTemplate();
  }

  generate(parserOutput: ParserOutput, outputPath?: string): { html: string; markdown: string } {
    const { types } = parserOutput;

    // Generate HTML
    const html = this.renderHTML(parserOutput);

    // Generate Markdown
    const markdown = this.renderMarkdown(parserOutput);

    if (outputPath) {
      this.writeDocs(outputPath, html, markdown);
    }

    return { html, markdown };
  }

  private getDefaultTemplate(): string {
    return `<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>{{title}}</title>
  <style>
    {{styles}}
  </style>
  {{extraHead}}
</head>
<body>
  <div class="storybook-container">
    <header>
      <h1>{{title}}</h1>
      <p class="subtitle">Generated from API response • {{timestamp}}</p>
      <input type="text" class="storybook-search" placeholder="Search types..." onkeyup="filterTypes(this.value)">
    </header>

    <main>
      {{typeHierarchy}}
      {{typeCards}}
    </main>

    <footer>
      <p>Generated by api-to-ts-interface skill</p>
    </footer>
  </div>

  <script>
    function filterTypes(query) {
      query = query.toLowerCase();
      document.querySelectorAll('.storybook-type-card').forEach(card => {
        const text = card.textContent.toLowerCase();
        card.style.display = text.includes(query) ? 'block' : 'none';
      });
    }

    function copyToClipboard(text) {
      navigator.clipboard.writeText(text).then(() => {
        alert('Copied to clipboard!');
      });
    }
  </script>
</body>
</html>`;
  }

  private renderHTML(parserOutput: ParserOutput): string {
    const interfaces = parserOutput.types.filter((t) => t.kind === 'interface');
    const types = parserOutput.types.filter((t) => t.kind !== 'interface');

    const hierarchyHTML = this.renderTypeHierarchy(parserOutput.types);
    const cardsHTML = [...interfaces, ...types]
      .map((type) => this.renderTypeCard(type))
      .join('\n');

    return this.template
      .replace(/{{title}}/g, this.title)
      .replace(/{{timestamp}}/g, new Date().toISOString())
      .replace(/{{styles}}/g, this.uiStyles)
      .replace(/{{typeHierarchy}}/g, hierarchyHTML)
      .replace(/{{typeCards}}/g, cardsHTML)
      .replace(/{{extraHead}}/g, '');
  }

  private renderTypeHierarchy(types: ParsedType[]): string {
    // Build dependency graph
    const typeMap = new Map<string, ParsedType>();
    for (const type of types) {
      typeMap.set(type.name, type);
    }

    // Find root types (not extended by others)
    const extendedMap = new Set<string>();
    for (const type of types) {
      if (type.extends) {
        for (const parent of type.extends) {
          extendedMap.add(parent);
        }
      }
    }

    const roots = types.filter((t) => !extendedMap.has(t.name));

    const buildHierarchy = (type: ParsedType, depth: number = 0): string => {
      const indent = '  '.repeat(depth);
      const children = types.filter((t) => t.extends?.includes(type.name));

      let html = `${indent}<li>${type.kind} <strong>${type.name}</strong>`;
      if (children.length > 0) {
        html += '\n' + indent + '  <ul>\n';
        for (const child of children) {
          html += buildHierarchy(child, depth + 2) + '\n';
        }
        html += indent + '  </ul>\n' + indent;
      }
      html += '</li>\n';
      return html;
    };

    const hierarchyHTML = roots.length > 0
      ? roots.map((r) => buildHierarchy(r)).join('')
      : types.map((t) => buildHierarchy(t)).join('');

    return `<div class="storybook-type-hierarchy">
      <h2>Type Hierarchy</h2>
      <ul>${hierarchyHTML}</ul>
    </div>`;
  }

  private renderTypeCard(type: ParsedType): string {
    const tagClass = type.kind;

    let content = `<div class="storybook-type-card" data-type="${type.name.toLowerCase()}">
      <h3>
        <span class="tag ${tagClass}">${type.kind}</span>
        ${type.name}
      </h3>`;

    if (type.extends && type.extends.length > 0) {
      content += `<p>Extends: ${type.extends.map((e) => `<code>${e}</code>`).join(', ')}</p>`;
    }

    if (type.fields && type.fields.length > 0) {
      content += `
      <table class="storybook-property-table">
        <thead>
          <tr>
            <th>Property</th>
            <th>Type</th>
            <th>Req</th>
            <th>Description</th>
          </tr>
        </thead>
        <tbody>`;

      for (const field of type.fields) {
        const reqClass = field.required ? 'required' : 'optional';
        const reqText = field.required ? '✓' : '○';
        const description = field.description || '';

        content += `
          <tr>
            <td><code>${field.name}</code></td>
            <td><code>${this.highlightType(field.type)}</code></td>
            <td class="${reqClass}">${reqText}</td>
            <td>${description}</td>
          </tr>`;
      }

      content += `
        </tbody>
      </table>`;
    }

    if (type.values && type.values.length > 0) {
      content += `
      <h4>Values</h4>
      <ul>`;
      for (const value of type.values) {
        content += `<li><code>${value}</code></li>`;
      }
      content += `</ul>`;
    }

    // Generate example JSON
    const example = this.generateExample(type);
    if (example) {
      content += `
      <div class="storybook-example">
        <strong>Example:</strong>
        <pre>${JSON.stringify(example, null, 2)}</pre>
      </div>`;
    }

    content += `</div>`;
    return content;
  }

  private highlightType(typeStr: string): string {
    // Simple type syntax highlighting
    const keywords = ['string', 'number', 'boolean', 'Date', 'any', 'void', 'never'];
    let highlighted = typeStr;

    for (const keyword of keywords) {
      const regex = new RegExp(`\\b${keyword}\\b`, 'g');
      highlighted = highlighted.replace(regex, `<span style="color: #e83e8c;">${keyword}</span>`);
    }

    // Highlight array brackets
    highlighted = highlighted.replace(/(\[\])/g, '<span style="color: #22863a;">$1</span>');

    return highlighted;
  }

  private generateExample(type: ParsedType): any | null {
    if (type.kind === 'interface' && type.fields) {
      const example: any = {};

      for (const field of type.fields) {
        if (field.required) {
          example[field.name] = this.generateExampleValue(field.type);
        }
      }

      if (Object.keys(example).length > 0) {
        return example;
      }
    }

    return null;
  }

  private generateExampleValue(typeStr: string): any {
    // Map TypeScript types to example values
    if (typeStr.includes('string')) return 'example string';
    if (typeStr.includes('number')) return 0;
    if (typeStr.includes('boolean')) return true;
    if (typeStr.includes('Date')) return '2024-01-01T00:00:00.000Z';

    // Array
    const arrayMatch = typeStr.match(/^(\w+)\[\]$/);
    if (arrayMatch) {
      const itemType = arrayMatch[1];
      return [this.generateExampleValue(itemType)];
    }

    // Union
    if (typeStr.includes('|')) {
      const unionTypes = typeStr.split('|').map((t) => t.trim());
      return this.generateExampleValue(unionTypes[0]);
    }

    // Object reference (nested interface)
    return { /* placeholder for nested object */ };
  }

  private renderMarkdown(parserOutput: ParserOutput): string {
    const lines: string[] = [];

    lines.push(`# ${this.title}\n`);
    lines.push(`_Generated: ${new Date().toISOString()}_\n`);

    for (const type of parserOutput.types) {
      lines.push(`## ${type.kind} \`${type.name}\``);

      if (type.extends && type.extends.length > 0) {
        lines.push(`_Extends: ${type.extends.join(', ')}_\n`);
      }

      if (type.fields && type.fields.length > 0) {
        lines.push('\n| Property | Type | Required | Description |');
        lines.push('|----------|------|----------|-------------|');

        for (const field of type.fields) {
          const req = field.required ? '✓' : '○';
          const desc = field.description || '';
          lines.push(`| \`${field.name}\` | \`${field.type}\` | ${req} | ${desc} |`);
        }
      }

      if (type.values && type.values.length > 0) {
        lines.push('\n**Values:**');
        for (const value of type.values) {
          lines.push(`- \`${value}\``);
        }
      }

      const example = this.generateExample(type);
      if (example) {
        lines.push('\n**Example:**');
        lines.push('```json');
        lines.push(JSON.stringify(example, null, 2));
        lines.push('```');
      }

      lines.push('');
    }

    return lines.join('\n');
  }

  private writeDocs(outputPath: string, html: string, markdown: string): void {
    if (!fs.existsSync(outputPath)) {
      fs.mkdirSync(outputPath, { recursive: true });
    }

    const htmlFile = path.join(outputPath, 'storybook.html');
    const mdFile = path.join(outputPath, 'README.md');

    fs.writeFileSync(htmlFile, html, 'utf8');
    fs.writeFileSync(mdFile, markdown, 'utf8');

    console.log(`Storybook docs written: ${htmlFile}, ${mdFile}`);

    // Also copy assets if specified
    if (this.assetsPath && fs.existsSync(this.assetsPath)) {
      const assetsDest = path.join(outputPath, 'assets');
      this.copyAssets(this.assetsPath, assetsDest);
    }
  }

  private copyAssets(source: string, dest: string): void {
    if (!fs.existsSync(dest)) {
      fs.mkdirSync(dest, { recursive: true });
    }

    const copyRecursive = (src: string, dst: string) => {
      const entries = fs.readdirSync(src, { withFileTypes: true });

      for (const entry of entries) {
        const srcPath = path.join(src, entry.name);
        const dstPath = path.join(dst, entry.name);

        if (entry.isDirectory()) {
          copyRecursive(srcPath, dstPath);
        } else {
          fs.copyFileSync(srcPath, dstPath);
        }
      }
    };

    try {
      copyRecursive(source, dest);
      console.log(`Assets copied to: ${dest}`);
    } catch (err) {
      console.warn(`Failed to copy assets: ${err}`);
    }
  }
}

// CLI entry point
function main(): void {
  const args = process.argv.slice(2);

  if (args.length < 1) {
    console.error('Usage: storybook.ts <generatedTypes.json> [--template <path>] [--assets <path>] [--output <dir>] [--title "My Docs"]');
    process.exit(1);
  }

  const inputFile = args[0];
  const options: StorybookOptions = {};

  // Parse arguments
  for (const arg of args.slice(1)) {
    if (arg.startsWith('--template=')) {
      options.templatePath = arg.split('=')[1];
    } else if (arg.startsWith('--assets=')) {
      options.assetsPath = arg.split('=')[1];
    } else if (arg.startsWith('--output=')) {
      options.outputPath = arg.split('=')[1];
    } else if (arg.startsWith('--title=')) {
      options.title = arg.split('=')[1];
    }
  }

  try {
    const content = fs.readFileSync(inputFile, 'utf8');
    const parserOutput: ParserOutput = JSON.parse(content);

    const storybook = new StorybookGenerator(options);
    const result = storybook.generate(parserOutput, options.outputPath);

    if (!options.outputPath) {
      console.log(result.html);
    }

    console.log('Storybook generation complete');
  } catch (err) {
    console.error('Storybook error:', err);
    process.exit(1);
  }
}

if (require.main === module) {
  main();
}

export { StorybookGenerator, ParsedType, ParsedField, ParserOutput, StorybookOptions };
